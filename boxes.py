#!/usr/bin/env python3

import argparse
import csv

from collections import defaultdict
from typing import Dict, List, Optional

import rgbcolour

PREAMBLE0 = """
// Generated by https://github.com/hillwithsmallfields/boxes/blob/trunk/boxes.py

wall_thickness = %g;
floor_thickness = %g;
ceiling_thickness = %g;
hole_standback = -wall_thickness * 4;

module hole(preshift, rot, postshift, dimensions, label) {
    translate(preshift) rotate(rot) translate(postshift) cube(dimensions);
}

module box(position, dimensions, colour, label) {
    color(colour) {
        translate(position) {
            // make this hollow by subtracting an inner cuboid
            difference() {
                cube(dimensions);
                translate([wall_thickness/2, wall_thickness/2, floor_thickness]) {
                    cube([dimensions[0]-wall_thickness, dimensions[1]-wall_thickness, dimensions[2]]);
                }
                children();
            }
        }
    }
}
"""
PREAMBLE1 = """
difference() {
  union() {
"""
PREAMBLE1DEBUG = """
union() {
"""

INTERAMBLE = """  }
  union() {
"""

INTERAMBLEDEBUG = """  }
color("red") union() {
"""

POSTAMBLE = """  }
}
"""

POSTAMBLEDEBUG = """  }
"""

# The __init__ methods for all the things we read from the CSV files
# each take the whole CSV row as their input.

class Box:

    """A cuboid positive space, such as a room, box, or shelf and the space it supports.
    Not a hole such as a door or window."""

    pass

    def __init__(self, data, definitions:dict):
        self.box_type = data.get('type', 'room')
        self.name = data['name']
        self.dimensions = [float(data.get('width')),
                           float(data.get('depth')),
                           float(data.get('height'))]
        self.position = [0.0, 0.0, 0.0]
        self.adjacent = data.get('adjacent')
        self.direction = data.get('direction')
        self.alignment = data.get('alignment')
        self.offset = data.get('offset', 0.0) or 0.0
        self.holes = []
        self.neighbours = {'left': [],
                           'right': [],
                           'front': [],
                           'behind': []}
        self.colour = data.get('colour', [.5, .5, .5, .5])
        if self.colour == "":
            self.colour = [.5, .5, .5, .5]
        if isinstance(self.colour, str):
            self.colour = rgbcolour.rgbcolour(self.colour, definitions['opacity'].value)

    def __str__(self):
        return "<box %s of size %s at %s to %s of %s, %s-aligned>" % (
            self.name,
            self.dimensions,
            self.position,
            self.direction, self.adjacent, self.alignment)

    def write_scad(self, stream):
        """Write the SCAD code for this box.
        Return a string describing the holes attached the box."""
        stream.write("""    box(%s, %s, %s, "%s");\n""" % (
            self.position,
            self.dimensions,
            ('"%s"' % self.colour) if isinstance(self.colour, str) else self.colour,
            self.name))
        return "".join(hole.scad_string(self)
                       for hole in self.holes)

def cell_as_float(row, name):
    """Convert the contents of a spreadsheet cell to a float.
    Empty cells are treated as 0.0"""
    value = row.get(name)
    return 0 if value in (None, "") else float(value)

class Hole:

    """A cuboid negative space to punch out of the wall of a box such as room.
    This represents doors and windows."""

    pass

    def __init__(self, data, definitions):
        self.name = data['name']
        join = data['type'] == 'join'
        reduction = definitions['wall_thickness'].value if join else 0
        self.dimensions = [float(data.get('width')) - reduction*2,# from one side of the hole to the other
                           float(data.get('depth')) - reduction,  # from bottom to top of the hole
                           definitions['hole_depth'].value]
        # the room that this hole is in one of the walls of:
        self.adjacent = data.get('adjacent')
        # which wall the hole is in (front, left, back, right):
        self.direction = data.get('direction')
        # from the floor to the bottom of the hole:
        self.height = cell_as_float(data, 'height') + definitions['floor_thickness'].value*1.001
        # how far from the start of the wall the hole starts:
        self.offset = cell_as_float(data, 'offset') + reduction

    def __str__(self):
        return "<hole %s %g from start of %s of box %s>" % (self.name, self.offset, self.direction, self.adjacent)

    def scad_string(self, parent):
        """Return the SCAD code for this hole."""
        # hole(preshift, rot, postshift, dimensions, label)
        return """    hole([%g, %g, %g], [90, 0, %g], [%g, %g, hole_standback], %s, "%s");\n""" % (
            parent.position[0] + (parent.dimensions[0] if self.direction == 'right' else 0),
            parent.position[1] + (parent.dimensions[1] if self.direction == 'back' else 0),
            parent.position[2],
            90 if self.direction in ('left', 'right') else 0,
            self.offset, self.height,
            self.dimensions,
            self.name)

    def write_scad(self, stream, parent):
        """Write the SCAD code for this hole."""
        stream.write(self.scad_string(parent))

class Constant:

    """A constant definition."""

    pass

    def __init__(self, data, _definitions):
        self.name = data['name']
        self.value = data['width']
        self.all_data = data

    def __str__(self):
        return "<defined constant %s=%s>" % (self.name, self.value)

class Type:

    """A type definition.
    """

    pass

    def __init__(self, data, _definitions):
        self.data = data
        self.name = data['name']
        self.dimensions = [float(data.get('width')),
                           float(data.get('depth')),
                           float(data.get('height'))]
        # Direct rows with this name in their type field to the implementation "Custom"
        makers[self.name] = makers['__custom__']
        print("Defined custom type", self.name)

class Custom:

    """A custom type, as defined by the Type type of row.

    This class is for instantiating the type, not defining it.  Row
    handlers for rows of custom types point here, regardless of the
    name of the custom type.

    """

    pass

    def __init__(self, data, definitions):
        self.box_type = data['type']
        self.name = data['name']
        self.dimensions = definitions[self.box_type].dimensions
        self.position = [0.0, 0.0, 0.0]
        self.adjacent = data['adjacent']
        self.direction = data.get('direction')
        self.alignment = data.get('alignment')
        self.colour = data.get('colour', [.5, .5, .5, .5])
        if self.colour == "":
            self.colour = [.5, .5, .5, .5]
        self.offset = float(data.get('offset', 0.0) or 0.0)
        self.data = data
        print("Instantiating custom feature of type", self.box_type, "and dimensions", self.dimensions, "adjacent to", self.adjacent)

    def write_scad(self, stream):
        """Write the SCAD code for this custom feature instance."""
        stream.write("""    box(%s, %s, %s, "%s");\n""" % (
            self.position,
            self.dimensions,
            ('"%s"' % self.colour) if isinstance(self.colour, str) else self.colour,
            self.name))
        return ""

# Define all the names for each of the functions to make an object
# from a spreadsheet row (since there are multiple names for each
# function, it is neater to write them this way, then invert the
# table):
names_for_makers = {
    lambda row, definitions: Box(row, definitions): ('room', 'shelf', 'shelves', 'box'),
    lambda row, definitions: Hole(row, definitions): ('door', 'window', 'join'),
    lambda row, definitions: Constant(row, definitions): ('constant',),
    lambda row, definitions: Type(row, definitions): ('type',),
    lambda row, definitions: Custom(row, definitions): ('__custom__',)}

# Invert the table, so we can look up row types in it:
makers = {
    name: maker
    for maker, names in names_for_makers.items()
    for name in names}

def position_dependents(definitions, dependents, box):
    """Position boxes dependent on a given box.
    Then position their dependents, etc."""
    if box.name in dependents:
        for dependent_name in dependents[box.name]:
            dependent = definitions[dependent_name]

            if isinstance(dependent, (Box, Custom)):
                # scan through the coordinates: X, Y, Z for
                # neighbouring boxes that begin where the current one
                # ends:

                for index, direction in enumerate(['right', 'behind', 'above']):
                    if dependent.direction == direction:
                        dependent.position[index] = (box.position[index]
                                                     + box.dimensions[index])

                for index, direction in enumerate(['left', 'front', 'below']):
                    if dependent.direction == direction:
                        dependent.position[index] = (box.position[index]
                                                     - dependent.dimensions[index])

                # scan through the coordinates: X, Y, Z for
                # neighbouring boxes that are coterminous with the
                # current one:

                for index, direction in enumerate(['left', 'front', 'bottom']):
                    if direction in dependent.alignment:
                        dependent.position[index] = (box.position[index]
                                                     + dependent.offset)

                for index, direction in enumerate(['right', 'back', 'top']):
                    if direction in dependent.alignment:
                        dependent.position[index] = (box.position[index]
                                                     + box.dimensions[index]
                                                     - dependent.dimensions[index]
                                                     + dependent.offset)

            elif isinstance(dependent, Hole):
                box.holes.append(dependent)
            else:
                print("Other type:", dependent)

            position_dependents(definitions, dependents, dependent)

DEFAULT_CONSTANTS = {
    'wall_thickness': 10,
    'hole_depth': 40,
    'floor_thickness': 10,
    'ceiling_thickness': -1     # so we can see into rooms from above
}

def define_constant(definitions, name, value):
    """Add a constant to the definitions."""
    definitions[name] = Constant({'name': name, 'width': value}, definitions)

def add_default_constants(definitions):
    """Set constants if not loaded from file."""
    for default_name, default_value in DEFAULT_CONSTANTS.items():
        if default_name not in definitions:
            define_constant(definitions, default_name, default_value)

def read_layout(filename:str, definitions:dict, limit=None):
    """Reads a file of layout data, returning a list of objects each made from a row."""
    with open(filename) as instream:
        return {row['name']: makers[row.get('type', 'room')](row, definitions)
                for row in list(csv.DictReader(instream))[0:limit]}

def adjust_dimensions(boxes):
    """Add some dimensional details."""
    wall_thickness = boxes['wall_thickness'].value
    floor_thickness = boxes['floor_thickness'].value
    ceiling_thickness = boxes['ceiling_thickness'].value

    # The dimensions of rooms are presumed to be given as internal:
    for box in boxes.values():
        if isinstance(box, Box) and box.box_type == 'room':
            box.dimensions[0] += wall_thickness # one half-thickness at each side
            box.dimensions[1] += wall_thickness # one half-thickness at each end
            box.dimensions[2] += floor_thickness + ceiling_thickness
        elif isinstance(box, Hole):
            box.dimensions[2] = wall_thickness * 8 # make sure it gets through
    return PREAMBLE0 % (wall_thickness, floor_thickness, ceiling_thickness)

def generate_tree(boxes):
    """Work out the tree structure of what depends on what."""
    dependents = defaultdict(list)
    first_box = None
    for box in boxes.values():
        if isinstance(box, (Box, Hole, Custom)):
            if box.adjacent == 'start':
                if 'start' in dependents:
                    print("There should be only one box dependent on 'start'.")
                first_box = box
            dependents[box.adjacent].append(box.name)
    return dependents, first_box

def show_tree(dependents, start='start', depth=0):
    """Show a tree of dependents."""
    if start in dependents:
        for child in dependents[start]:
            print("|   " * depth + child)
            show_tree(dependents, child, depth+1)

def make_scad_layout(input_file_names:List[str],
                     output:str,
                     opacity:float = 1.0,
                     verbose:bool=False,
                     debug:bool=False,
                     limit=None):
    """Read layout definition files and produce a 3D model file from them."""

    definitions = {}
    add_default_constants(definitions)
    define_constant(definitions, 'opacity', opacity)

    for input_file_name in input_file_names:
        definitions.update(read_layout(input_file_name, limit=limit, definitions=definitions))

    dependents, first_box = generate_tree(definitions)

    if verbose:
        show_tree(dependents)

    if 'start' not in dependents:
        print("No starting point given")

    sized_preamble = adjust_dimensions(definitions)

    # Now process the tree
    first_box.position = [0.0, 0.0, 0.0]
    position_dependents(definitions, dependents, first_box)

    with open(output, 'w') as outstream:
        outstream.write("""// Produced from %s\n""" % input_file_name)
        outstream.write(sized_preamble)
        outstream.write(PREAMBLE1DEBUG if debug else PREAMBLE1)
        holes = "".join(box.write_scad(outstream)
                        for box in definitions.values()
                        if isinstance(box, (Box, Custom)))
        outstream.write(INTERAMBLEDEBUG if debug else INTERAMBLE)
        outstream.write(holes)
        outstream.write(POSTAMBLEDEBUG if debug else POSTAMBLE)

def get_args():
    """Get the command line args."""
    parser = argparse.ArgumentParser()
    parser.add_argument("--output", "-o",
                        help="""The OpenSCAD file to write the output to.""")
    parser.add_argument("--opacity", "--alpha", "-a",
                        type=float, default=1.0,
                        help="""The opacity of walls, on a scale from 0 (transparent) to 1 (opaque).""")
    parser.add_argument("--verbose", "-v",
                        action='store_true',
                        help="""Show the feature tree.""")
    parser.add_argument("--debug", "-d",
                        action='store_true',
                        help="""Show the negative features as red blocks.""")
    parser.add_argument("--limit", "-l",
                        type=int,
                        help="""Use only this many rows of the input, for incremental debugging.""")
    parser.add_argument("input_file_names",
                        nargs='+',
                        help="""A CSV file with fields as described in the accompanying README.md file.""")
    return vars(parser.parse_args())

if __name__ == '__main__':
    make_scad_layout(**get_args())
